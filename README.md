# Трекер задач сотрудников

Серверное приложение, состоящее из двух основных компонентов:

RESTful API на фреймворке Django Rest Framework — обеспечивает CRUD операции для сотрудников и задач, а также 
предоставляет два специальных эндпоинта для получения информации о загруженности сотрудников и важных задачах. 
Предназначен для интеграции с другими системами (веб-приложения, мобильные приложения).

Telegram Bot на фреймворке aiogram — предоставляет удобный интерфейс для сотрудников и менеджеров для быстрого доступа 
к задачам и их статусам прямо в мессенджере. Бот взаимодействует с RESTful API для получения и обновления данных.

Трекер задач позволит компании эффективно управлять заданиями, назначенными сотрудникам, и обеспечивать прозрачность 
процессов выполнения задач. Это поможет в равномерном распределении нагрузки между сотрудниками и своевременном 
выполнении ключевых задач.

# Инструкция по установке и использованию разработанного функционала приложения
1. Клонируйте репозиторий:
```
git clone https://github.com/4usnok/employee_tasks.git
```
2. Установите зависимости:
```
poetry install
```
3. Активировать окружение
```
poetry env activate
```
# Содержание проекта
## Приложение `employee_table`
Приложение предназначенное для работы с таблицей сотрудников
1. Содержит `models.py`:
* Модель для таблицы сотрудников `EmployeeTable`
2. Содержит `serializers.py`:
* Сериализатор для модели `EmployeeTable` -> `EmployeeTableSerializer`
3. Содержит `views.py`:
* `EmployeeTableList` -> Просмотр списка таблиц сотрудников
* `EmployeeTableCreate` -> Создание таблицы сотрудников
* `EmployeeTableDestroy` -> Удаление таблицы сотрудников
* `EmployeeTableUpdate` -> Редактирование таблицы сотрудников
* `EmployeeTableRetrieve` -> Просмотр одной таблицы сотрудников
* `EmployeeListWithActiveTasks` -> Просмотр списка таблиц сотрудников с активными задачами
* `FindEmployee` -> Реализует поиск по сотрудникам, с определенными задачами
4. Содержит `tests.py` -> для тестов
5. Содержит директорию `migrations` для миграций

## Приложение `task_table`
Приложение предназначенное для работы с таблицей задач
1. Содержит `models.py`:
* Модель для таблицы задач `TaskTable`
2. Содержит `serializers.py`:
* Сериализатор `TaskTableSerializer` -> для модели `TaskTable`
* Специальный сериализатор `TaskTableSerializer` -> для вывода списка объектов в формате: 
{Важная задача, Срок, [ФИО сотрудника]}
3. Содержит `views.py`:
* `TaskList` -> Просмотр списка таблиц задач
* `TaskTableCreate` -> Создание таблицы задач
* `TaskTableDestroy` -> Удаление таблицы задач
* `TaskTableUpdate` -> Редактирование таблицы задач
* `TaskTableRetrieve` -> Просмотр одной таблицы задач
* `TaskListNotWork` -> Запрашивает из БД задачи, которые не взяты в работу, 
но от которых зависят другие задачи, взятые в работу
4. Содержит `tests.py` -> для тестов
5.. Содержит директорию `migrations` для миграций

## Приложение `users`
Приложение предназначенное для работы с пользователями
1. Содержит `models.py`:
* Модель пользователя `User`

## Прочие файлы
1. `.env.sample` -> Заполняется в первую очередь(предназначен для заполнений host, port, пароля от бд и тд.)
2. `Readme.md` -> содержит описание проекта
3. `docker-compose.yaml` -> Один конфигурационный файл, который объединяет весь функционал в 
многоконтейнерном Docker-приложении
4. `Dockerfile.txt` -> файл с инструкциями для автоматического создания Docker-образов, 
включающий установку зависимостей и настройку окружения.
5. `pyproject.toml` -> список зависимостей и настроек проекта в poetry
6. `.github` -> в директории `workflows` файл `ci.yml` -> он предназначен для настройки деплоя по методу CI на github
7. `nginx` содержит два файла: 
* `Dockerfile` -> предназначен для настроек nginx
* `nginx.conf` -> в файле находятся глобальные директивы, которые определяют общие настройки для всего сервера.
8. `.coveragerc` -> файл с настройками для покрытия
9. `.flake8` -> файл с настройками для линтера `flake8`
10. `mypy.ini` -> файл с настройками для линтера `mypy`
11. `htmlcov` -> директория с html-файлом покрытия тестами проекта
12. `run_bot.py` -> модуль для запуска тг-бота
13. `handlers` -> пакет с хэндлерами `employee_handlers.py` и `task_handlers.py`
14. `tests` -> директория с тестами хэндлеров

## Работа с программой
1. Запуск сервера осуществляется командой: `python manage.py runserver`
2. Ручное создание и запуск контейнера:
`docker run -d `
--name my-django-employee-task `
-p 8000:8000 `
-v employee-task-media-volume:/empoyee-task/media `
-e DEBAG=1 `
my-django-employee-task `
3. Запуск бота производится из корневой директории: `python bot.py`

## Инструкции по настройке удаленного сервера и деплоя

# Создание и настройка виртуальной машины и сервера

Шаг 1. Создание виртуальной машины и обновление системы:
1. Создание ВМ происходит на Yandex Cloud по адресу:
`console.yandex.cloud/`
2. Подключение к ВМ:
`ssh -l kakas 84.201.160.200`

Шаг 2. Перед подключением к ВМ, необходимо убедиться, что все пакеты имеют актуальные версии, 
а система имеет рабочее состояние
1. Команда для обновления списка пакетов:
`sudo apt update`
2. Команда для обновления всех установленных пакетов до их последних версий:
`sudo apt upgrade`

Шаг 3. Установка Докера состоит из последовательности команд, которые можно найти по ссылке в документации:
https://docs.docker.com/engine/install/ubuntu/

Шаг 4. Настройка файрвола
1. Сначала проверьте состояние файрвола с помощью команды:
`sudo ufw status`
Если файрвол отключен, активируйте его:
`sudo ufw enable`
2. Теперь откройте необходимые порты:
Порт 80 для HTTP:
`sudo ufw allow 80/tcp`
Порт 443 для HTTPS:
`sudo ufw allow 443/tcp`
3. Порт 22.
Чтобы обеспечить доступ к вашему серверу по SSH, необходимо не забыть открыть порт 22. 
Открытие порта 22:
`sudo ufw allow 22/tcp`

Шаг 5. Проверьте настройки файрвола.
После добавления портов, проверьте состояние файрвола снова, чтобы убедиться, что порт 22 также открыт:
`sudo ufw status`

Ожидаемый результат:
В результате выполнения команды вы должны увидеть, что порт 22 находится в состоянии ALLOW наряду с портами 80 и 443. 
Это означает, что ваш сервер будет доступен для SSH-подключений, а также для веб-трафика.

Теперь ваш сервер безопасен и доступен для управления через SSH, а также для обработки HTTP и HTTPS запросов.

# Ручной деплой приложения

Ручной деплой состоит из нескольких шагов:

Шаг 1. Подключение к ВМ 
В `Bash` или `Powershell` необходимо ввести команду:
`ssh username@1.234.567.89`, где
username -> это никнейм ВМ
1.234.567.89 -> это публичный IPv4

Шаг 2. Клонирование репозитория:
команда -> `git clone https://github.com/4usnok/employee_tasks.git`

Шаг 3. Права доступа
Настройка прав пользователя иногда может потребоваться и она состоит из следующих шагов:
1. Добавьте пользователя в группу docker:
`sudo usermod -aG docker $USER`
2. Применить изменения групп (выйдите и войдите заново, или выполните):
`newgrp docker`
3. Проверить, что пользователь добавлен в группу docker:
`groups`
4. Проверить работу Docker:
`docker ps`

Шаг 4. Проверка и подгрузка недостающих файлов:
Выполните команду для проверки доступных файлов:
1. После того, как мы склонировали проект, необходимо зайти в его корневую директорию:
`cd employee_tasks`
2. Проверить наличие веток:
`git branch -r`
3. Подгрузка недостающих файлов:
Баш может не найти нужные для деплоя файлы. В этом случае, необходимо будет обратиться на удалённый репозиторий, 
вместе с этим, баш подгрузит все недостающие файлы:
Команда -> `git ls-tree -r origin/work-for-nikolay`, где ветка work-for-nikolay ветка разработчика
`origin` -> это для удалённых веток, поэтому необходимо оставить
4. Переключение на ветку:
`git checkout work-for-nikolay`

Шаг 5. Запуск docker-compose или по другому -> деплой:
`docker-compose up -d`

# Деплой по методу CI
Деплой по методу CI осуществляется на гитхабе во вкладке Actions, настройки сервера и 
контейнера находятся в директории: `/.github/workflows` в файле `ci.yml`

# Полезные команды
* Запуск виртуального окружения poetry: `poetry env activate`
* Запуск сервера: `python manage.py runserver`,
* Создание суперюзера(админка): `python manage.py createsuperuser`,
* Создание миграций: `python manage.py makemigrations`,
* Сохранение миграций: `python manage.py migrate`,
* Откат всех миграций: `python manage.py migrate name_migration`, где `name_migration` -> название миграции.
* Создания файла с покрытием `.coverage`: `coverage html`
* Посмотреть покрытие unit-тестами: `coverage report`
* Запуск обработчика очереди (worker) для получения задач и их выполнения: `celery -A config worker -l INFO`
* Запуск redis-server: `./redis-server.exe`
* Запуск redis-cli: `./redis-cli.exe`
* Сборка образа: `docker build -t my-django-employee-task .`
* Запуск контейнера: `docker run -p 8000:8000 my-django-employee-task`
* Просмотр контейнеров: `docker images`
* Вывод логов контейнеризации: `docker-compose logs db`
* Запускает все сервисы, определенные в файле: `docker-compose up`
